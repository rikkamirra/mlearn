Перевод на с английского


Оригинал


История компьютерных языков - классическое десятилетие, 1950-е годы


В первой из серии статей о развитии компьютерных языков мы рассмотрим борьбу за создание первых языков высокого уровня.


В конце 50-х годов мир программирования имел троицу: Фортран, Кобол и Алгол, а история компьютерных языков завершила самый важный этап. 


История вычислений обычно рассказывается с точки зрения аппаратного обеспечения, и в результате мы склонны думать о прогрессе, как о том, насколько меньше, быстрее и дешевле становились компьютеры. Вычисление - это не только применение электроники, а другая сторона медали. Вычисление также касается программирования, и история языков программирования содержит значительную часть реальной истории вычислений.


Хотя компьютерное оборудование резко изменилось за очень короткое время, его основные принципы остались прежними. Настолько, что даже Чарльз Бэббидж (1792-1871), отец компьютера, не будет слишком много разбираться в IBM PC. Он может не понимать транзисторы, микросхемы, магнитную запись или телевизионные мониторы, но он признает тот же принцип работы процессора, который работает с памятью.


Можно сказать, что единственное реальное различие между компьютером Бэббиджа и сегодняшним компьютером - это технология, используемая для реализации дизайна, и вы только немного приблизитесь к правде. Однако одно и то же утверждение не относится к программному обеспечению. У Бэббиджа, вероятно, даже не было четкого представления о программировании как о чем-то отдельном от дизайна его машины, о чем не повторилось разработчиками оборудования с тех пор!


Первым человеком, которому вы можете вручить титул «программист», как правило, считается Августа Ада, графиня Лавлейс (1815-52). Этот навряд ли известный персонаж помог Бэббиджу совершенствовать свой дизайн для механического компьютера и в процессе придумал программирование, но есть те, кто будет утверждать, что ее роль была намного меньше.


Ее вклад был признан тем, что в ее честь назвали язык программирования Ada. По многочисленным свидетельствам она была архитипичным программистом с больше чем одной областью интереса - она ​​потеряла много денег, мечтая о безумном алгоритме азартных игр! 


Самое важное наблюдение заключается в том, что Ада, похоже, понимает, что именно программное обеспечение и абстрактное выражение алгоритмов сделали машину мощной и способной делать практически все.


Суть всего в том, что языки программирования и программирования имеют свою собственную жизнь отдельно от аппаратных средств, используемых для их реализации. Без аппаратного обеспечения они были бы не чем иным, как абстрактными играми разума, но как только у вас будет компьютер, независимо от того, насколько примитивна реализация, большинство сложных и интересных идей находятся в разработке программного обеспечения.


По возможности, программа представляет собой список инструкций, а компьютер - это машина, которая будет подчиняться этому списку инструкций. Характер машины, которая выполняет приказы, не настолько сложна, как характер инструкций, которые она выполняет, и язык, используемый для их написания.


Увидев проблему
Если вы можете программировать, даже немного, идея языка программирования кажется ослепительно очевидной.


Это очень затрудняет понимание того, что было время, когда идея языка программирования была намного менее очевидной и даже считалась нежелательной! Сегодня программистам не нужно ничего знать о базовом дизайне машины. Для них программа построена на языке программирования, и именно этот язык является реальностью. Как машина выполняет эту программу, более или менее неактуально.


Мы стали сложными, уйдя от упрощенного компьютерного оборудования. Однако в первые дни этого не было. Ранние программисты работали с точки зрения «машинного кода», и это было практически всего в одном шаге от программирования с помощью паяльника! Следует также иметь в виду, что большинство программистов того времени были людьми, которые держали руку на создании машины или обучались электронике. Эта путаница между электронной техникой и программированием сохранялась до сравнительно недавнего времени.


Программист машинного кода видит машину как набор нумерованных мест памяти, а операции, которые могут выполняться, задаются числовыми кодами. Программа и данные должны храниться в памяти, и программист должен отслеживать, где все.


Например, компьютер может иметь два рабочих кода


01 x y


что означает добавление содержимого ячейки памяти x в содержимое ячейки памяти y и


02 x y


означает вычитание содержимого ячейки памяти x из содержимого ячейки памяти y. Затем программа будет записана в виде длинного списка чисел, как в 01 10 15 02 18 17 и т. Д. Эта программа означает добавление ячейки памяти от 10 до 15, а затем вычитание ячейки памяти 18 из 17, но это далеко не сразу очевидно из случайный взгляд. Тем не менее программисту в этот день было похоже на чтение стандартного английского языка.


Поскольку каждый день они выпускали программы, этот список операционных кодов был зафиксирован при их сознании, и для второго и следующего типов было и чтение, и запись таких программ. 


На этом раннем этапе программирование заключалось в том, чтобы объединить команды машины, чтобы получить желаемый результат. 


Проблемы с машинным кодом
Машинный код имел и все еще имеет одно огромное преимущество - потому что это то, что машина понимает напрямую, это эффективно.


Однако его недостатки очень серьезны и легко перевешивают соображения эффективности. Трудно было обучать программистов машинного кода, было слишком легко ошибаться, и ошибки было трудно обнаружить.


Чтобы понять машинный код, вы должны знать, как работает машина, и для этого требуется определенный уровень сложности и знаний об оборудовании. Сначала это не имело значения, потому что программисты были людьми, которые строили машину, и, следовательно, они обнаружили, что все это совершенно естественно. Однако, как только требовалось больше программистов, трудности объяснения машинного кода потенциальным программистам, которые ничего не знали об оборудовании, стали очевидными и реальной проблемой.


Проблема с поиском ошибок в машинных кодах была просто связана с отсутствием непосредственного значения, которое имели коды. После того, как вы некоторое время программировали, ваш мозг начал читать 01, как «Добавить», но даже тогда, когда читал 01 10 24 как «Добавить ячейку памяти 10 в ячейку памяти» 24, не было никаких подсказок относительно того, какие места памяти использовались как 10 и 24. Машинный код легко читается машинами, но людям всегда трудно понять. 


ассемблер
Решение заключалось в том, чтобы использовать короткие, но содержательные буквенные коды - мнемонику - для каждой операции. Поэтому вместо того, чтобы писать 01 10 15, программист должен писать ADD 10 15. Конечно, прежде чем компьютер сможет понять это, он должен быть переведен обратно в машинный код.


Сначала это было сделано вручную, но у какого-то неизвестного пионера появилась идея заставить компьютер сделать эту утомительную работу - и появился первый ассемблер. Ассемблер - это программа, которая считывает мнемонику и преобразует ее в эквивалентный машинный код.


Трудно сказать, кто изобрел ассемблер, по-видимому, потому, что он был изобретен случайным образом в разных местах. Полагают, что влиятельная книга того времени « Подготовка программ для цифрового компьютера » Уилкса, Уилера и Гилла (1951) несет ответственность за распространение идеи, и авторам также часто приписывают первое использование термина " ассемблер "означает программу, которая собирает еще одну программу, состоящую из нескольких разделов, в одну программу. Со временем этот термин был ограничен, чтобы охватывать только программы, которые переводят читаемые символы в гораздо менее читаемый цифровой машинный код.


Первые ассемблеры сделали именно это, но как только идея заставить машину перевести символическую программу в числовые коды операций, не потребовалось много времени, чтобы придумать другие задания, которые она могла бы сделать, чтобы упростить программирование.


Лучшей и самой важной идеей было введение символов, используемых для представления адресов мест памяти. Например, используя такую ​​символическую адресацию, программист мог написать общую сумму ADD и оставить ассемблер работать там, где в памяти будет храниться сумма и общая сумма.


Верьте или нет, это очень сложная идея и требует много дополнительного программирования на ассемблере, чтобы заставить ее работать. По существу, вам нужно настроить таблицу, таблицу символов, где собираются имена и назначать адреса памяти каждому символу по мере перевода программы.


Это ввело три важные идеи -
* концепция того, что позднее стало известно как символическая переменная или переменная для краткости,
* идея таблицы символов, т.е. хранилища, где вы могли бы искать символы и узнать, что они представляют, машинный код, данные или адрес данных. 


и, возможно, самое важное


* что программисты могут использовать свое искусство, чтобы упростить программирование.


Это стало началом языкового взрыва.


Макросборщик
После простых сборщиков появились макросборщики и автокоды. Ассемблер перевел одно имя, такое как ADD, в один машинный код. Макроассемблер расширил эту идею до перевода определенного пользователем имени в ряд инструкций в машинный код.


Например, если вы обнаружили, что вы часто добавляли его в определенную ячейку памяти и тестировали, чтобы убедиться, что это меньше, чем верхний предел, вы можете написать макрос с именем INCRT x, который увеличивает и анализирует местоположение памяти x. Макроассемблер расширил каждое появление INCRT в программе, используя определение, предоставленное программистом.


Сегодня большинство ассемблеров - это макросборщики, и даже языки высокого уровня имеют макрообъекты. С нашей точки зрения трудно понять, насколько мощными макросборками были - вы могли бы создать очень сложные макросы, которые почти превратили ассемблер в язык высокого уровня. 


Рождение компилятора
В некотором смысле макроассемблер просто позволяет программистам устанавливать сокращенные формы для часто используемых фрагментов кода. Но они также были важны, потому что они представили идею перехода от примитивного машинного кода к более мощным и сложным инструкциям, которые переведены в машинный код.


Это основная идея компилятора, и она освобождает дизайн языков программирования от простого копирования базового машинного кода.


Вместо использования макросов для расширения простого языка ассемблера, почему бы не использовать тот же метод для создания совершенно нового и машинного независимого языка высокого уровня?


С нашей точки зрения это кажется очевидным и желательным следующим шагом. Это означает, что вы можете создать простой в использовании и мощный язык, который может быть понят любым компьютером, на котором есть компилятор.


Но у программистов того времени было много сомнений относительно языков высокого уровня. Они скептически относились к возможности создания компилятора языка высокого уровня вообще, и если бы это было возможно, они сомневались в его эффективности.


Некоторые из причин этого отношения были обусловлены эмоциями, а не здравым смыслом. После стольких лет использования машинного кода непосредственно лучшие программисты думали о программе с точки зрения того, что машина действительно делала, и языки высокого уровня угрожали попасть между программистом и машиной. Поскольку вычислительное время стоило так много, казалось, было сумасшествием изобретать способ, который мог бы упростить программирование, но с реальным расходом времени компьютера. 


Принятие языков высокого уровня рассматривалось как потеря контроля над создаваемыми программами. Общая жалоба заключалась в том, что если компилятор был использован для генерации машинного кода, тогда возникла бы опасная ситуация, когда никто не понимал окончательный код.


Сегодня, конечно, никто не беспокоится о том, что ни один человеческий глаз никогда не рассматривает машинный код основных программ приложений. Но в те дни машинный код был языком, на который задумывались большинство программистов! 


Фортран доказывает, что это возможно
Единственный способ доказать, что эффективный компилятор может быть изготовлен, - это на самом деле произвести его, но это приводит к центральной трудности раннего построения компилятора - арифметических выражений. Если бы не арифметические выражения, переход от макросборников к компиляторам был бы тривиальным. Действительно, вы можете утверждать, что единственное действительно важное различие между языком макросов и языком высокого уровня - это способность свободно использовать арифметические и другие типы выражений. 


Проблема с арифметическим выражением заключается в том, что порядок, в котором должно произойти, не совпадает с порядком, в котором они записаны. Это, конечно, причина, по которой школьники находят сложную арифметику и более позднюю алгебру трудными. 


Например, если вы представляете компилятор с выражением 2 + 3 * 5, он сканирует символы слева направо и генерирует код для добавления от 2 до 3, а затем умножает результат на 5, но это, конечно, даст неправильный ответ. В математике было традиционно делать умножения перед добавлением, а правильный машинный код должен сначала выполнить умножение, а затем добавить 2 к результату.


Когда вы впервые видите эту проблему, возникает соблазн поверить, что ее можно исправить каким-то простым специальным дополнением к методу, который использует компилятор для перевода языка высокого уровня. Если вы попробуете это, вы найдете это почти невозможным, потому что арифметическое выражение может быть сколь угодно сложным, например (2 + 3 * 5 + 4/6) * 10 + 16- (14 + 15) * 8.


Нужен общий способ перевода арифметического выражения, любое арифметическое выражение в код, выполняющий каждую операцию в правильном порядке.


Такой метод, оценка стека была обнаружена во время разработки Fortran Джона Бэкуса, возглавляющего команду программистов IBM. Проект Fortran занял четыре или пять лет, начиная с 1954 года, и ему удалось доказать жизнеспособность языков высокого уровня.


Название Fortran означает FORmula TRANslator - его полное название -  The IBM Formula Translating System . Fortran был продуктом IBM, но даже ребенок Big Blue того времени должен был удивляться тому, как быстро он стал языком вычислений.


Современные программисты одинаково удивлены тем, что 60-летний Фортран по-прежнему остается популярным языком для некоторых важных приложений, в частности, в области науки и техники - климатического моделирования, например. Он эволюционировал от оригинального Fortran 1, Fortran II, Fortran 66 (также известного как Fortran IV), Fortran 77, Fortran 90 и 95, и в настоящее время мы используем Fortran 2008, и мы ведем работу над более поздней версией (2015) который должен быть выпущен в 2018 году. Несмотря на то, что он развился, он не изменился из-за любого признания и по-прежнему остается верным своему оригинальному дизайну, что программист Fortran 1 сможет что-то выполнить в Fortran 2008.


Поскольку первый язык высокого уровня Fortran явно важен, но он также повлиял на многие поколения программистов, особенно когда вы принимаете во внимание популярность BASIC, которая была языком, полученным непосредственно из Fortran. Fortran также важен, поскольку он стал началом роста IBM как доминирующей силы в области вычислений. Как и Fortran, так и IBM.


Многие из ключевых возможностей, которые мы ожидаем от языка высокого уровня, включая арифметические и логические выражения; цикл DO (ранняя форма цикла FOR); заявление IF; подпрограммы; массивы; и форматирование было введено Fortran. И все же Fortran оставался рядом с базовой машиной с конструкциями, такими как арифметика, если


if(expression) doneg, dozero,dopos


где инструкция, которая была подпрыгнута, зависела от значения выражения - отрицательного, нулевого или положительного. Причиной этой нечетной команды была машина IBM, для которой был создан Fortran, для которой была указана машинная команда, которая была трехсторонней ветвью на значении в регистре.


МакКрекен


Помимо запуска высокоуровневого программирования Fortran подпитывал растущий рынок компьютерных книг. Книга Даниэля Д. МакКракена была стандартным текстом и проходила через ряд изданий.


 


Фортран был языком, который был только на одном уровне, удаленном от ассемблера. Его огромный вклад состоял в том, чтобы решить проблему преобразования арифметических выражений в код - вот почему она называется For-Tran в конце концов. Сегодня простой язык, такой как Fortran 1, будет студенческим проектом для реализации, а метод, который он использовал для выполнения перевода - алгоритм стека, - не очень ценится, но он первым доказал, что это было возможно и практично.


Конечно, находясь так близко к аппаратной аппаратуре, Fortran не был блочным структурированным языком, и у него был печально известный номер линии GOTO, который впоследствии вызвал бы столько споров. GOTO и номера строк также были унаследованы Basic. Конечно, сегодня мы не используем номера строк и прямые переходы, и это одна из отметок языка, подобного Фортрану.


Другим интересным фактом является то, что Фортран представил идею о том, что переменные с именами, начинающимися с любых из I, J, K, L, M и N, были целыми числами, то есть буквами от I до N для INteger. Даже сегодня вы найдете, что программисты имеют тенденцию использовать один и тот же набор букв для целых чисел, возможно, даже не зная почему.


Учитывая опасения по поводу эффективности высокоуровневых языков, вы не можете быть слишком жесткими на машинных зависимостях Fortran. 


Языки размножаются
Как только Фортран показал, как создавать компиляторы, открылись шлюзы. Можно было спроектировать и реализовать любой язык, о котором мог мечтать программист. Я полагаю, что мы должны быть благодарны за то, что больше языков не уловили, но идея языков, специфичных для приложений.


Fortran 1 был по существу научным языком, подходящим для хрустания числа - он имел числа с плавающей запятой и комплексные числа. Первая версия не имела возможности обрабатывать текст, а более поздние версии решали проблему только путем преобразования символов в числовые значения - символы Hollerith! 


Это сделало Fortran явно непригодным для использования в бизнесе, в результате был создан бизнес-ориентированный язык Cobol - COmmon. Г-жа Глоп Хоппер сделала большую часть ранней работы. На этом этапе развития казалось, что новый язык будет создан для удовлетворения всех потребностей. Cobol использовал очень длинный естественный язык, как инструкции. Он сделал все возможное, чтобы как можно больше отличаться от Фортрана, и поэтому возможность писать сложную арифметику, как в Формуле-переводе, не была особенностью. То есть Cobol не использовал алгоритм стека для перевода арифметического форума на код, который вам пришлось бы написать в очень простой форме. Даже назначение было предотвращено такими командами, как


Move Income To Total Subtract Expenses


и так далее. 


Cobol был разработан для бизнеcсменов и бизнес-программистов, явно не понимающих арифметики, не говоря уже об алгебре. Возможно, у него не было возможности выполнять сложную арифметику, но у нее была возможность обрабатывать текст и работать с записями - чего не хватало Фортрану.


Следующим основным языком, Алгол (ALGOrithmic Language), было изобретение компьютерных ученых, чтобы обеспечить последовательный и компактный способ представления программ для публикации и как язык исследования. Удивительно это означало конец бума. Алгол 58 был чем-то вроде перерыва, хотя и был кружком компьютерной науки. В нем были представлены многие идеи, которые мы считаем сегодня само собой разумеющимися - например, различие между присваиванием: = и равенством =, использование трех частей для цикла для индекса: = начальный предел увеличения и вложенные процедуры с локальными определениями областей. Алгол был первым из блочных структурированных стековых языков, которые развивались в C, C ++, C #, Java и так далее. 


Другое большое различие заключается в том, что Алгол использовал стек для своей модели памяти. Fortran и Cobol использовали кучу и выделенные переменные в начале программы. Алгол представил идею автоматических локальных переменных, которые были сохранены в стеке вызовов. Как только эта идея стала установлена, она более или менее захватила мир. Почти каждый язык сегодня использует фрейм стека для хранения локальных переменных и кучу для хранения глобальных переменных. Троицы Фортрана - для ученых и инженеров, Cobol - для бизнеса и Algol - для компьютерных людей, оказались достаточными, и даже сегодня многие новые языки могут быть классифицированы как Fortran-, Cobol- или Algol-подобные. Хотя следует признать, что группа, подобная Алголу, на сегодняшний день является наиболее распространенной. 


Хотя и Cobol и Algol начали свое развитие в конце 50-х годов, их влияние и история простираются до 60-х годов. Они действительно являются семенами в течение следующих десяти лет развития языка. История Algol и Cobol представлена ​​в следующей статье, посвященной 60-м годам. Фортран был слепой блейзер, за которым следовали другие.


Его производство было и остается основным событием в истории языков программирования, и вполне уместно, что 50-е годы следует рассматривать как десятилетие Фортрана.


 


История компьютерных языков - классическое десятилетие, 1950-е годы
Компьютерные языки по комитету - 1960-е годы
Рост власти людей - Компьютерные языки в 70-е годы
К объектам и функциям - 1980-е годы




Веб - ранние годы


Время перед Всемирной паутиной? Да, был один. На самом деле Интернет довольно молод, начиная с 1991 года, когда Тим Бернерс-Ли, основанный в ЦЕРНе, изобрел его и запустил первый в истории веб-сайт. 


На самом деле вряд ли было правдоподобно, что было время до «Сети», но дело в том, что это произошло чуть более 25 лет назад, так как это было впервые задумано и тем более с тех пор, как оно стало широко использоваться. На самом деле есть много пользователей, которые сегодня даже не понимают, что Интернет - это не Интернет, а Интернет - это не Интернет. 


Трудно отследить идеи, которые привели к Интернету к одной оригинальной мысли, но было много попыток найти способы организации информации, чтобы облегчить доступ.


В 1945 году Ванневар Буш написал статью « Как мы можем думать» , описывая, как машины могут использоваться, создавая сети информации, извлекаемые ассоциациями между ними. Система, которую он изобрел, использовала считыватели микрофильмов для связывания информации. Вы можете видеть, что технология не была готова к идее, но идея была хорошей:


Рассмотрим будущее устройство для индивидуального использования, которое является своего рода механизированным частным файлом и библиотекой. Ему нужно имя, и, чтобы монета случайным образом, «memex» будет делать. Memex - это устройство, в котором человек хранит все свои книги, записи и сообщения и механизирован, чтобы с ним можно было справиться с большей скоростью и гибкостью. Это расширенное близкое дополнение к его памяти. 


В 1965 году Тед Нельсон изобрел слово «гипертекст» в научной статье «  Комплексная обработка информации: структура файла для комплекса, изменение и неопределенность» и предложил систему, очень похожую на Интернет, но ничего из этого не вышло, подобная судьба была охвачена множеством очень общих философских схем построения систем, которые связывали знания вместе таким образом, чтобы революционизировать человеческую мысль.


Проблема заключалась в том, что у глубоких мыслителей было много идей о том, как сделать данные более доступными, но им не хватало ключевых технологий для реализации всего, что сработало. Возможно также, что они предлагали системы, которые были слишком сложными с небольшим набором простых принципов. 


Соединение CERN
Тот, который выделялся из остальной идеи, был «Запросить», гипертекстовую систему, внедренную британским ученым Тимом Бернерсом-Ли, чтобы помочь ему запомнить связи между людьми, работающими в физике высоких энергий ЦЕРН.


В 1980 году я написал программу для отслеживания программного обеспечения, с которым я был вовлечен в систему управления PS. Called Inquire, он позволяет хранить фрагменты информации и связывать связанные фрагменты в любом случае. Чтобы найти информацию, один продвигался по ссылкам с одного листа на другой, скорее, как в старой компьютерной игре «Приключения». Я использовал это для своей личной записи людей и модулей. Это было похоже на приложение Hypercard, выпущенное в последнее время Apple для Macintosh. Разница заключалась в том, что Inquire, хотя и не имел причудливой графики, работал в многопользовательской системе и позволял многим людям получать доступ к тем же данным.


 


После кратковременного заклинания от ЦЕРНа Бернерс-Ли вернулся на более постоянную должность там, а в 1989 году представил предложение под названием « Большая гипертекстовая база данных с типизированными ссылками » для создания более амбициозной гипертекстовой системы, которая использовала бы, к тому времени хорошо налаженный Интернет для обмена гипертекстовыми связями. Идея заключалась в том, чтобы позволить работникам CERN легко сохранить и получить доступ ко всей информации, которую они производят:


«... Вот почему« сеть »заметок со ссылками (например, ссылками) между ними гораздо более полезна, чем фиксированная иерархическая система.


При описании сложной системы многие люди прибегают к диаграммам с кругами и стрелками. Круги и стрелки оставляют один свободный, чтобы описать взаимоотношения между вещами таким образом, что таблицы, например, этого не делают.


Система, в которой мы нуждаемся, похожа на диаграмму кругов и стрелок, где круги и стрелки могут стоять за что угодно. Мы можем назвать узлы окружностей, а ссылки со стрелками. Предположим, что каждый узел похож на небольшую заметку, сводную статью или комментарий. Я не слишком обеспокоен тем, имеет ли он текст или графику, или и то, и другое ».


Первоначально его предложение не получило ответа, но он все же начал работать над этой идеей.


В 1990 году он написал HTTP-протокол передачи гипертекста, изобрел HTML-текст с гипертекстовой разметкой, написал клиентский браузер и первый веб-сервер. В более позднем предложении описывался проект:


Проект состоит из двух этапов: во-первых, мы используем существующее программное и аппаратное обеспечение, а также реализуем простые браузеры для рабочих станций пользователя на основе анализа требований к потребностям в доступе к информации с помощью экспериментов. Во-вторых, мы расширяем область приложений, предоставляя пользователям возможность добавлять новые материалы.


Первый этап должен занять 3 месяца с полным комплектованием рабочей силы, второй этап - еще на 3 месяца, но этот этап более открытый, и в него будет включен обзор потребностей и пожеланий.


Требуемая рабочая сила - 4 программиста и программист (один из которых может быть членом). Каждый человек работает с определенной частью (например, поддержка конкретной платформы).


Веб-сервер был установлен на info.cern.ch, и это был первый веб-сервер, из которого все росло. Веб опубликовал 6 августа 1991 года, но это событие было в значительной степени незаметно для мира!


Чтобы отпраздновать 20-летие этого исторического мероприятия, команда в CERN обязалась восстановить первый в мире веб-сайт и сохранить некоторые из цифровых активов, связанных с рождением Интернета. Работа, проделанная в 2013 году, означает, что вы все равно можете просмотреть первый в мире веб-сайт, который первоначально был размещен на компьютере NexT от Berners-Lee, и был о самой Всемирной паутине. Стоит щелкнуть по  реплике этого примитивного сайта,  чтобы понять, насколько далеко мы пришли.




По словам Дэна Нойса в  блоге проекта , этот первый веб-сайт «был, вероятно, довольно одиноким», поскольку мало кто имел доступ к браузеру или веб-серверам. Одним из тех, у кого есть браузер, был Тим Бернерс-Ли, и этот скриншот имеет оригинальный браузер NeXT в 1993 году:


 


Кажется почти пугающим думать об этом самом первом Веб-сайте, сидящем там, где никто не может просмотреть его и несколько других страниц, на которые нужно ссылаться. На данный момент, конечно, не было бы необходимости в Google, и вы могли бы правильно сказать: «Вы посетили Веб-сайт?»


Что именно создал Бернерс-Ли?
Простым ответом является HTTP и HTML. Но, конечно, вы должны иметь в виду, что у него также был большой план того, как все собралось вместе, чтобы создать то, что мы теперь называем сетью.


HTTP был и является очень простым протоколом запроса / ответа. Браузер отправил запрос на файл на сервер, и сервер передает файл в браузер. Это более или менее все, что нужно. Со временем он был разработан, но все же это всего лишь способ для веб-браузера запросить файл. 


HTML был использован для форматирования данных в файлах. Он состоял из форматирования «тегов», которые браузер использовал для представления текста пользователю. Сначала диапазон тегов был очень ограниченным - заголовки, абзацы, курсивный текст и так далее. У него были гипертекстовые ссылки, но они не были доступны клиенту в виде современной веб-страницы - вам нужно было ввести ссылочный номер!


Обратите внимание, что Интернет был построен поверх Интернета, как он тогда существовал. Он использовал Интернет и его протоколы более низкого уровня, такие как TCP / IP для передачи данных. Например, не было необходимости изобретать доменные имена или IP-адреса, все это уже существовало как часть Интернета. HTTP просто использовал TCP / IP для запроса и отправки файлов с сервера в клиентский браузер. Браузер просто превратил HTML в видимую веб-страницу. Щелчок по ссылке на странице заставил клиентский браузер запрашивать файл с этого конкретного сервера. Идея имени домена также должна была быть расширена путем включения пути к файлу для создания URL-адреса. Это указывает сервер, с которым нужно связаться, а также местоположение и имя файла, который будет извлечен. 


Интернет, возможно, продолжался довольно успешно без изобретения Сети, но Интернет нуждался в Интернете в качестве инфраструктуры связи.


Webless!
В то время люди пользовались Интернетом, но Интернета не было, и с сегодняшнего дня это трудно понять.


Что они сделали?


Перед Интернетом было множество способов получить информацию. Из протоколов единственными, которые все еще широко используются, являются группы новостей, электронная почта и FTP - протокол передачи файлов.


Когда Интернет был в первую очередь доступным, было много потенциальных пользователей, которые просто не видели смысла. Вы можете подключить свой компьютер к другому компьютеру, независимо от того, где он был в мире, для свободного доступа. В то время все привыкли к тому факту, что связь стоит больше, чем расстояние, на которое проезжали данные. Например, местные телефонные звонки были дешевыми, большие расстояния были более дорогими, а межконтинентальные звонки требовали банковского кредита. Полагаю, идея заключалась в том, что вы заплатили за кабель, который вы использовали.


Переключение пакетов изменило эту модель «заряд по расстоянию», и это было не редкость для ранних демонстраций Интернета, чтобы провести вас в быстром мировом турне по компьютерам в отдаленных местах. Это было страшно - сколько денег мы тратили? Ответ был таким же, как и подключение к локальному компьютеру, и более чем часто ничего. 


Сначала все интернет-ресурсы позволяли вам подключаться к удаленному компьютеру, как если бы вы были терминалом. Мы по-прежнему используем протокол Telnet сегодня, но в те дни это было более или менее все, что у вас было. После подключения к удаленному компьютеру вы можете просматривать свои системы регистрации и перечислять содержимое файлов. Это было очень скучно - если у компьютера не было данных, которые вам действительно нужны. 


Еще один важный факт, который следует иметь в виду, заключается в том, что все в Интернете в это конкретное время было основано на тексте. Все было сделано с помощью простых консольных программ, и все дело в наборе. Вам даже пришлось вводить ссылочные номера, чтобы следовать ссылкам.


 


linebrowse


Оригинальный браузер - вам пришлось вводить цифры, чтобы следить за ссылками! Вы можете попробовать другие старые браузеры на сайте www.dejavu.org .


 


Постепенно начали развиваться дополнительные услуги, которые стали возможны благодаря Интернету и возможностям, которые он предлагает для междугородной связи и обмена данными. У нас были электронная почта, FTP и система под названием Gopher. Это было изобретено в Университете Миннесоты, и какое-то время казалось, что он может заполнить нишу, которую делает Интернет. Это был способ поиска документов, состоящих из набора вложенных меню. Вы подключились к компьютеру и представили вам меню верхнего уровня, и вы медленно работали по меню, пока не достигли интересующего вас документа. Затем вы обычно загружаете его, чтобы просмотреть его позже.


Вы также можете выполнять поиск по иерархии меню, но не по самим документам. Это было похоже на использование удаленной файловой системы. Если вы считаете, что Гофер примитивен - в то время, когда все думали, что это здорово, и много рассмеялся о его имени - Идите ... Получите это?


 


gopher n. 1. Любой из различных короткохвостых, роющих млекопитающих семейства Geomyidae, из Северной Америки. 2. (Amer. Colloq.) Родной или житель Миннесоты: государство Гофер. 3. (Amer. Colloq.) Тот, кто выполняет поручения, делает нечетные задания, получает или доставляет документы для сотрудников офиса. 4. (компьютерное) программное обеспечение, следуя простенькому протоколу для прорывания через Интернет TCP / IP.


Начало запроса комментариев: 1436, описывающее Gopher


В конечном счете, Гофер был убит Интернетом. Бернерс-Ли рассказывает историю о Университете штата Миннесота, не желая отказаться от возможности взимать плату за лицензию в будущем, отпугивая исполнителя сервера. Однако тот факт, что Керн помещал Веб в общественное достояние, был лишь одним из его преимуществ. Это была более сложная система, и она медленно росла в возможностях, чтобы стать тем, что у нас есть сегодня.


Ранняя сеть, однако, была текстовой только как Gopher, и это тоже может стать сюрпризом. Бернерс-Ли считал, что Интернет должен быть о серьезных вещах, и изображения не должны быть частью каждой страницы. Веб - это все о текстовых документах. Несмотря на это, Интернет был настолько привлекательным, что даже без фотографий он снялся.


 


рысь


Есть люди, которые до сих пор находят Lynx, браузер раннего текстового режима намного лучше, чем любой из современных браузеров


В 1992 году первый браузер был доступен только по FTP-загрузке. В начале 1993 года на Интернет приходилось всего 0,1% трафика в Интернете; к концу года это увеличилось до 1%. И снова с точки зрения современности вы действительно должны спросить, какие другие 99% Интернета используются? 


В конце 1993 года насчитывалось 200 веб-серверов, а шесть месяцев спустя их было 1500. Сеть просто росла и росла и быстро становилась единственным способом найти и сделать доступной информацию.  


Netscape
Следующая часть веб-истории менее известна. В 1992 году Марк Андреессен был студентом Университета штата Иллинойс в Урбана-Шампейн, и он решил реализовать новый браузер - Мозаику.


Это будет доступно на различных платформах - Unix, Windows и Mac. К концу 1993 года более миллиона человек использовали его, и было бы неплохо пойти на коммерческую деятельность. Он объединился с экс-боссом Silicon Graphics Джим Кларком и нанял всех, кроме одной из первоначальной команды из университета. Университет не выпустил браузер для новой компании, но они продолжались независимо. Университет не просто согласился с этой позицией и предъявил иск, заявив, что Mosaic Netscape, компания, украл имя Mosaic и код браузера. Мозаика Netscape поселилась за 3 миллиона долларов и сменила название на Netscape и браузер на Navigator.


 


Команда Netscape должна была написать браузер снова с нуля. В то время маркетинговый план был очень странным. Вместо того, чтобы продавать продукт, Netscape отдал его - если вы не захотели использовать его в коммерческих целях, когда он обвинил вас в этом. За один год в Netscape было 65 миллионов пользователей, и Microsoft испугалась.


 


У него также был очень раздражен Тим Бернерс-Ли. 


Netscape начал внедрять инновации и расширять HTML, добавляя новые теги, которые создавали более удобное форматирование и встроенную графику. Это сделало типичную веб-страницу гораздо интереснее, чем смотреть, но Бернерс-Ли думал, что это делает все слишком тривиально.


Новый тег изображения, который позволял создавать изображения на любой веб-странице, вызывал особую тревогу! Он рассказывал Андрессену несколько раз, но это не имело никакого значения. Мало того, что Интернет растет и растет, так же как и его основные технологии.


Навигатор представил гиперссылку - интерактивную ссылку на другую веб-страницу или местоположение на той же странице - и это был полностью графический интерфейс с кнопками и захватывающий вид.


Проблема поиска
Сеть продолжала развиваться, поскольку новые люди видели новые возможности. Большая проблема заключалась в поиске чего-либо. В первые дни может быть только один Веб-сайт, но число росло настолько быстро, что вы просто не знали, что там было. Первоначальная идея заключалась в том, что гиперссылка позволит вам перейти к информации, относящейся к любому интересующему вас вопросу. Это была гипотеза ранних пионеров - что гиперссылки было достаточно для организации всего человеческого знания. К сожалению, они не рассчитывали на случайный рост сети ссылок. Трудно было найти вещи. 


В 1994 году Брайан Пинкертон создал небольшое приложение, искатель Интернета, который искал в Интернете и создал индексы того, что было доступно. Это была первая поисковая система, и в 1995 году она была продана America Online, а затем в 1996 году была куплена компанией Excite Inc.


Примерно в то же время два студента из Стэнфордского университета, Дэвид Фило и Джерри Янг, создали более упорядоченный веб-каталог под названием «Еще один иерархический случайный Oracle» или Yahoo!


Вы можете не поверить в это, но большая часть организации и построения этих ранних индексов была реализована людьми, просматривающими ссылки, найденные искателями. На самом деле, только когда Google в форме Ларри Пейджа и Сергея Брина изобрел рейтинг страницы, появился полностью автоматический веб-поиск. Даже сегодня Google использует много людей, чтобы помочь в этом процессе - что-то, что он не обсуждает.


Это все еще так, что большая проблема для Сети - это найти вещи. 


Microsoft присоединяется к
В 1995 году Netscape выпустила Navigator 2 и Sun выпустила Java - только теперь Microsoft просыпалась с тем, что ее оставили.


По причинам, которые мы должны догадаться, Microsoft убедила себя в том, что Интернет - это причудливая причуда, и он может отмахнуться, создав свою собственную сеть - MSN (MicroSoft Network).


Клиент MSN был включен в Windows 95, и, хотя он мог выглядеть как веб-браузер, технология была нестандартной и не основана на HTML. Его можно лучше всего описать сегодня как пример подключенного приложения. Вы запустили его на своем рабочем столе и предоставили вам доступ к страницам информации, предоставленным Microsoft. 


Microsoft полагала, что MSN и Интернет могут сосуществовать, и пользователи будут подписываться на MSN, потому что они предоставили контент, который был выше, чем вы могли бы получить в Интернете. Однако для Microsoft не потребовалось много времени, чтобы понять, что существует веб-сайт, а затем есть MSN, и большинство пользователей захотели в Интернете.


Браузерные войны
В быстром ответе многие интерпретировали как отчаяние Microsoft выпустила Internet Explorer 1. К 1996 году более 75% пользователей Сети использовали Navigator, и, поскольку Explorer 1 был не очень хорош, казалось, что Microsoft не восстановит основания для того, чтобы он потерялся, игнорируя Интернет.


Но все с Netscape было не так замечательно, как казалось. Microsoft отдавала «Проводника» без «if» или «но». Это было бесплатно, независимо от того, кто вы или за что вы его использовали. Netscape Navigator, с другой стороны, был бесплатным, если вы были студентом, но в противном случае это стоило чего-то. Всегда была бесплатная бета-версия, если вы не хотели платить за реальную вещь. Если вы заплатили, то плохая новость заключалась в том, что Netscape постоянно меняла свою ценовую политику, и это было непоследовательно - способ раздражать ваших платежных клиентов, если они когда-либо были.


Это было началом эры, которая каждые три месяца демонстрировала новую бета-версию, а также использование Интернета и его пользователей в качестве огромного пула тестеров программного обеспечения. Это также начало Web как инструмент программного обеспечения.


Руководство Netscape также было убеждено в том, что его продукт был лучше и имел такой огромный рыночный лидер, что ему нечего было делать, чтобы обеспечить его сохранение. С другой стороны, у Microsoft был Билл Гейтс, чтобы довести его до конечного успеха. Проводник пришел с Windows и остался свободным. Версия 3 была намного лучше, чем 1, и она представила множество новых технологий, включая ActiveX. Microsoft пыталась подтолкнуть все так быстро, что она упреждала стандарты и пыталась установить свою собственную технологию как де-факто стандарты.


Причиной для паники является недавно воскрешенная идея (от Google в виде Chrome OS), которую веб-браузер мог бы их разрешить. Манипуляции в Интернете захватывали всех настолько, что казалось вполне вероятным, что браузер вполне может узурпировать Windows как a самая популярная операционная система. Браузер мог запускать программы в виде Java-апплетов, и теоретически он, по крайней мере, не нуждался в операционной системе. Любая машина и браузер были полны сами по себе и различия между Windows, Linux, Unix или каким-либо другим.


Это явно не было хорошей перспективой для Microsoft, и поэтому она была инновационной, чтобы создать не только лучший браузер, но и браузер, зависящий от Windows. С огромным успехом Explorer идея о том, что браузер был и есть все, что вам нужно более или менее исчезло из сознания Microsoft и почти всех остальных - но это все равно так же верно, и Firefox OS и Chrome OS доказывают, что вы вообще не нужна традиционная ОС.


Netscape потерял долю на рынке и в конечном итоге был куплен AOL. Между тем Microsoft интегрировала браузер так тесно с Windows, что изобрела «Active Desktop», в которой рабочий стол стал браузером. Другие новые идеи, большинство из которых умерли, были «push» - способность серверов отправлять данные, которые никогда не запрашивали клиенты, а каналы - переход к модели телевизора для браузера.


Похоже, что пользователи сопротивлялись всем попыткам превратить Интернет во что-то пассивное и просто маркетинговый инструмент. Тем не менее попытки Microsoft сделать Интернет центральным для Windows в конечном итоге приземлили их в суде для антиконкурентной практики.


Сегодняшняя сеть
Реальная и прочная проблема с Интернетом не носит чисто технологический характер. Все дело в содержании. Пользователи часто жалуются, что, когда они ищут информацию в Интернете, на что они находят много и много ссылок, которые переходят на другие страницы ссылок, еще больше ссылок и когда вы найдете ссылку, которая не переходит на другую страницу ссылок это часто неработающая ссылка.


Проблема в том, что когда дело доходит до предоставления информации, Интернет - это очень любительское дело с добавлением нескольких сайтов, созданных академическими или государственными учреждениями, которые предоставляют реальную информацию. В противном случае сеть сохраняется в службах поддержки производителей, онлайн-магазинах, маркетинге и энтузиастов. Возможно, этого достаточно. Есть несколько удивительных примеров, которые показывают, что вам не нужна профессиональная инфраструктура для создания хорошего и надежного контента - например, Wikipedia.


Возможно, если бы поиск был хорошим. Все основные поисковые системы страшно работают с тем, чтобы направлять пользователей на сайты, которые они могли бы искать. Некоторые из них связаны с коммерческими влияниями - платные результаты поиска и индивидуальный поиск. Но это также недооценивает трудности разработки того, что является актуальным, и что является высоким качеством. Существует множество веб-блогов, которые действительно полезны, но практически не имеют трафика и поэтому умирают от отсутствия интереса. Это ошибка поисковой системы. На данный момент все, что мы можем сделать, это продвигать использование социальных сетей для передачи ссылок, которые оказались интересными. Это работает после первоначального открытия.


Пользователи ожидают, что Сеть будет бесплатной и попытается запустить информационные услуги, которые должны быть оплачены, чтобы встретиться с небольшим энтузиазмом. В течение некоторого времени реклама обещала частичное решение, но это дает слишком мало дохода для финансирования качественной информации. Если Интернет должен улучшить следующую задачу, это найти способ финансировать контент, а не изобретать новые технологии. Или, может быть, реальное решение - найти новые технологии, которые могут финансировать контент.